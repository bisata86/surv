


<html lang="it">

<head>
    <title></title>
    <meta name="theme-color" content="black">
    <meta name="msapplication-navbutton-color" content="black">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style type="text/css">
        body {
          padding: 0;
          margin: 0;
          overflow: hidden;
        } 
        .lifebar, .manabar {
          height: 10px;
          width: 100%;
          border: 1px solid black;

          box-sizing: border-box;
        }
        .lifebar div {
          height: 100%;
          background: green;
        }
        .manabar div {
          height: 100%;
          background: blue;
        }

        @media (orientation: portrait) {
          #canvas {
            width: 100vw;
            height: auto;
            border-bottom: 1px soldi black;
            /*border: 1px solid black;
            width: 90vw;
            height: auto;
            position: absolute;
            top: 30;
            left: 0;
            right: 0;
            margin: auto;*/
          }
        }
        @media (orientation: landscape) {
          #canvas {
            width: auto;
            height: 100vh;
          }
        }
    </style>
    <style type="text/css">
          :root {
              --error-bg-color: #EF6F6C;
              --gray-color:#465775;
              --main-bg-color:white;
              --main-color:black;
            }
            ::-webkit-scrollbar {
          display: none;
        }
            .center {
          text-align: center;
        }
              .panel {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: auto;
            font-size: 20px;
            width: max-content;
            height: max-content;
            z-index: 4;
            width: 90vw;
            background: white;
            max-height: 100vh;
            overflow: scroll;
            border-radius: 5px;
            max-width: 350px;
        }
        .panel > div {
              padding: 15px;
              nobackground: var(--main-bg-color);
              /* margin: 10px; */
              font-size: 15px;
        }
        .panel > div:first-child {
              padding-top: 30px;
              border-radius: 5px 5px 0 0;
        }
        .panel > div:last-child  {
              padding-bottom: 30px;
              border-radius: 0 0 5px 5px;
        }
        .panel > div:active {
              nobackground: gray;
        }
      

        .panelButton {
            box-shadow: 0px 0px 1px 1px var(--main-color);
            background-color: var(--main-bg-color);
            border-radius: 6px;
            display: inline-block;
            cursor: pointer;
            color: var(--main-color);
            font-family: Arial;
            font-size: 15px;
            font-weight: bold;
            padding: 6px 35px;
            text-decoration: none;
            max-width: 100%;
            width: 200px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            box-sizing: border-box;
            position: relative;
        }
        .panelButton:hover {
          color: var(--main-bg-color);
          background-color:var(--main-color);;
        }
        .panelButton:active {
          position:relative;
          top:1px;
        }




        .panrelOverlay {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: auto;
            background-color: var(--main-color);
            z-index: 3;
            opacity: .2;
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
    <script type="text/javascript">
      class JoystickController
      {
        // stickID: ID of HTML element (representing joystick) that will be dragged
        // maxDistance: maximum amount joystick can move in any direction
        // deadzone: joystick must move at least this amount from origin to register value change
        constructor( stickID, maxDistance, deadzone )
        {
          this.id = stickID;
          let stick = document.getElementById(stickID);

          // location from which drag begins, used to calculate offsets
          this.dragStart = null;

          // track touch identifier in case multiple joysticks present
          this.touchId = null;
          
          this.active = false;
          this.value = { x: 0, y: 0 }; 

          let self = this;

          function handleDown(event)
          {
              self.active = true;

            // all drag movements are instantaneous
            stick.style.transition = '0s';

            // touch event fired before mouse event; prevent redundant mouse event from firing
            event.preventDefault();

              if (event.changedTouches)
                self.dragStart = { x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY };
              else
                self.dragStart = { x: event.clientX, y: event.clientY };

            // if this is a touch event, keep track of which one
              if (event.changedTouches)
                self.touchId = event.changedTouches[0].identifier;
          }
          
          function handleMove(event) 
          {
              if ( !self.active ) return;

              // if this is a touch event, make sure it is the right one
              // also handle multiple simultaneous touchmove events
              let touchmoveId = null;
              if (event.changedTouches)
              {
                for (let i = 0; i < event.changedTouches.length; i++)
                {
                  if (self.touchId == event.changedTouches[i].identifier)
                  {
                    touchmoveId = i;
                    event.clientX = event.changedTouches[i].clientX;
                    event.clientY = event.changedTouches[i].clientY;
                  }
                }

                if (touchmoveId == null) return;
              }

              const xDiff = event.clientX - self.dragStart.x;
              const yDiff = event.clientY - self.dragStart.y;
              const angle = Math.atan2(yDiff, xDiff);
            const distance = Math.min(maxDistance, Math.hypot(xDiff, yDiff));
            const xPosition = distance * Math.cos(angle);
            const yPosition = distance * Math.sin(angle);

            // move stick image to new position
              stick.style.transform = `translate3d(${xPosition}px, ${yPosition}px, 0px)`;

            // deadzone adjustment
            const distance2 = (distance < deadzone) ? 0 : maxDistance / (maxDistance - deadzone) * (distance - deadzone);
              const xPosition2 = distance2 * Math.cos(angle);
            const yPosition2 = distance2 * Math.sin(angle);
              const xPercent = parseFloat((xPosition2 / maxDistance).toFixed(4));
              const yPercent = parseFloat((yPosition2 / maxDistance).toFixed(4));
              
              self.value = { x: xPercent, y: yPercent };
            }

          function handleUp(event) 
          {
              if ( !self.active ) return;

              // if this is a touch event, make sure it is the right one
              if (event.changedTouches && self.touchId != event.changedTouches[0].identifier) return;

              // transition the joystick position back to center
              stick.style.transition = '.2s';
              stick.style.transform = `translate3d(0px, 0px, 0px)`;

              // reset everything
              self.value = { x: 0, y: 0 };
              self.touchId = null;
              self.active = false;
          }

          stick.addEventListener('mousedown', handleDown);
          stick.addEventListener('touchstart', handleDown);
          document.addEventListener('mousemove', handleMove, {passive: false});
          document.addEventListener('touchmove', handleMove, {passive: false});
          document.addEventListener('mouseup', handleUp);
          document.addEventListener('touchend', handleUp);
        }
      }
    </script>
    <script type="text/javascript">

        var app;
        window.onload = function () {
            Vue.component('menu-item', {
                  props: ['item','all'],
                  template: '<div v-on:keyup.enter="keyup(item)" :class="item.class">{{item.text}}<div @click="action(item)" v-if="item.html" v-html="item.html" :class="{ panelButton : item.onclick}"></div></div>',
                  created() {
                    //$('body').addClass('noscroll')
                  },
                  destroyed() {
                    //$('body').removeClass('noscroll')
                },
                methods: {
                  action: function (a) {
                    if(a.onclick)
                      a.onclick()
                  },
                  keyup: function (a) {
                    if(a.onkeyup)
                      a.onkeyup(a)
                  },
                  
                }
            })
            Vue.component('canvas-item', {
              props: ['g'],
              template: '<div><canvas id="canvas" :width="g.w" :height="g.h"></canvas></div>',
              mounted: function(){
                var c = document.getElementById("canvas");
                var ctx = c.getContext("2d");
                ctx.clearRect(0, 0, c.width, c.width);

                var gapx = (250-this._props.g.p.x)
                var gapy = (250-this._props.g.p.y)

                //console.log(gapx)

                var img = document.getElementById("bg");

                ctx.drawImage(img, gapx%this._props.g.w, gapy%this._props.g.h, this._props.g.w, this._props.g.h);


                ctx.drawImage(img, (gapx%this._props.g.w)-this._props.g.w, gapy%this._props.g.h, this._props.g.w, this._props.g.h);
                ctx.drawImage(img, (gapx%this._props.g.w)+this._props.g.w, gapy%this._props.g.h, this._props.g.w, this._props.g.h);

                ctx.drawImage(img, gapx%this._props.g.w, (gapy%this._props.g.h)-this._props.g.h, this._props.g.w, this._props.g.h);
                ctx.drawImage(img, gapx%this._props.g.w, (gapy%this._props.g.h)+this._props.g.h, this._props.g.w, this._props.g.h);

                ctx.drawImage(img, (gapx%this._props.g.w)+this._props.g.w, (gapy%this._props.g.h)+this._props.g.h, this._props.g.w, this._props.g.h);
                ctx.drawImage(img, (gapx%this._props.g.w)-this._props.g.w, (gapy%this._props.g.h)+this._props.g.h, this._props.g.w, this._props.g.h);
                ctx.drawImage(img, (gapx%this._props.g.w)+this._props.g.w, (gapy%this._props.g.h)-this._props.g.h, this._props.g.w, this._props.g.h);
                ctx.drawImage(img, (gapx%this._props.g.w)-this._props.g.w, (gapy%this._props.g.h)-this._props.g.h, this._props.g.w, this._props.g.h);


                //aurea
                ctx.fillStyle = "yellow";
                ctx.globalAlpha   = .5;   
                ctx.beginPath();
                ctx.arc(250, 250, this._props.g.p.aurea, 0, 2 * Math.PI);
                ctx.fill()
                ctx.closePath();
                ctx.globalAlpha   = 1;  
                

                /*ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(250, 250, this._props.g.p.d, 0, 2 * Math.PI);
                ctx.fill()
                ctx.closePath();*/
                var img = document.getElementById("hero");
                if(this._props.g.p.x>this._props.g.p.prevx || 
                  (this._props.g.p.x==this._props.g.p.prevx && this._props.g.p.facing != 'right')
                  ) {
                  ctx.save();
                  ctx.scale(-1, 1);
                  ctx.drawImage(img, (250-(this._props.g.p.d))*-1, 250-(this._props.g.p.d), this._props.g.p.d*-2, this._props.g.p.d*2);
                  ctx.restore();
                  this._props.g.p.facing = 'left'
                } else if(this._props.g.p.x<this._props.g.p.prevx  || 
                  (this._props.g.p.x==this._props.g.p.prevx && this._props.g.p.facing == 'right')
                  ) {
                  ctx.drawImage(img, (250-(this._props.g.p.d)), 250-(this._props.g.p.d), this._props.g.p.d*2, this._props.g.p.d*2);
                  this._props.g.p.facing = 'right'
                } else {

                }
                


                //ctx.fillStyle = "black";
                //ctx.rect(250-25,250+this._props.g.p.d+15,50,5)
                //ctx.stroke()
                ctx.fillStyle = "green";
                ctx.fillRect(250-25,250+this._props.g.p.d+15,(this._props.g.p.l*50/this._props.g.p.ml),5)

                ctx.fillStyle = "red";
                var img;
                for (var i = this._props.g.enemies.length - 1; i >= 0; i--) {
                    var e = this._props.g.enemies[i];
                    ctx.globalAlpha   = .5+(e.l*.5/e.ml);
                    if(e.type==0) img = document.getElementById("villain")
                    if(e.type==1) img = document.getElementById("villain2")
                    ctx.drawImage(img, e.x+gapx-(e.d*2), e.y+gapy-(e.d*2), e.d*4, e.d*4);
                }
                ctx.globalAlpha   = .5;
                ctx.fillStyle = "rgb(10,100,"+this._props.g.p.bulletDamage%250+")";
                var img = document.getElementById("bullet");
                for (var i = this._props.g.p.bullets.length - 1; i >= 0; i--) {
                    let e = this._props.g.p.bullets[i];
                    ctx.beginPath();
                    ctx.arc(e.x+gapx, e.y+gapy, e.d, 0, 2 * Math.PI);
                    ctx.fill()
                    ctx.closePath();
                    //ctx.drawImage(img, e.x+gapx-(e.d), e.y+gapy-(e.d), e.d*2, e.d*2);
                }
                ctx.globalAlpha   = 1;
                ctx.fillStyle = "violet";
                var img = document.getElementById("powerup");
                for (var i = this._props.g.collectables.length - 1; i >= 0; i--) {
                    let e = this._props.g.collectables[i];
                    ctx.drawImage(img, e.x+gapx-(e.d*2), e.y+gapy-(e.d*2), e.d*4, e.d*4);
                    /*ctx.beginPath();
                    ctx.arc(e.x+gapx, e.y+gapy, e.d, 0, 2 * Math.PI);
                    ctx.fill()
                    ctx.closePath();*/
                }
                ctx.fillStyle = "blue";
                var img = document.getElementById("turret");
                ctx.globalAlpha   = 1
                for (var i = this._props.g.turrets.length - 1; i >= 0; i--) {
                    let e = this._props.g.turrets[i];
                    if(e.facing=='right') {
                      img = document.getElementById("turret");
                    } else {
                      img = document.getElementById("tturret");
                    }
                    //ctx.globalAlpha  = e.l/e.ml;
                    //console.log(e.l/e.ml,ctx.globalAlpha)
                    ctx.drawImage(img, e.x+gapx-(e.d*2), e.y+gapy-(e.d*2), e.d*4, e.d*4);

                    /*ctx.rect(e.x+gapx-(e.d*2),e.y+gapy-(e.d*2),50,5)
                    ctx.stroke()*/

                    ctx.fillStyle = "green";
                    ctx.fillRect(e.x+gapx-(e.d*2),e.y+gapy+(e.d)*2,(e.l*50/e.ml),5)


                }
                //ctx.globalAlpha   = 1;
              }
            })
            Vue.component('heromana-item', {
              props: ['p'],
              template: '<div class="manabar"><div v-bind:style="{width: (p.mana*100/p.manaLimit)+\'%\' }"></div></div>'
            })
            Vue.component('stats-item', {
              props: ['p','e','v'],
              template: '<div class="">'+
              '<div class="">kills  {{p.kills}}</div>'+
              '<div class="">Enemies left {{e.length}}</div>'+
              '<div class="">v {{v}}</div>'+
              //'<div class="">speed: {{p.speed}}</div>'+
              //'<div class="">size: {{p.d}}</div>'+
              //'<div class="">bullets speed: {{p.bulletSpeed}}</div>'+
              //'<div class="">bullets size: {{p.bulletSize}}</div>'+
              //'<div class="">bullet damage: {{p.bulletDamage}}</div>'+
              //'<div class="">frequency: {{p.shootFrequency}}</div>'+
              '</div>'
            })
            Vue.component('joypad-item', {
              props: ['joypad'],
              template: '<div id="joy" style=" opacity:.5; width: 100%;"><div id="stick1" style="width: 100vw;height:100vh;position:absolute;top:0px;"> </div>    </div>',
              mounted: function(){
                  let joystick1 = new JoystickController("stick1", 64, 8); 

                  function update()
                  {

                    if(!app) return
                    if(!app.dataObj.mainInterval) return
                    var dest = app.dataObj.g.p.x+joystick1.value.x*app.dataObj.g.p.speed;
                    //if(dest>app.dataObj.g.p.d && dest<app.dataObj.g.w-app.dataObj.g.p.d)
                      app.dataObj.g.p.prevx=app.dataObj.g.p.x
                      app.dataObj.g.p.x=dest

                    var dest = app.dataObj.g.p.y+joystick1.value.y*app.dataObj.g.p.speed;
                    //if(dest>app.dataObj.g.p.d && dest<app.dataObj.g.h-app.dataObj.g.p.d)
                      app.dataObj.g.p.y=dest
                  }

                  function loop()
                  {
                    requestAnimationFrame(loop);
                    update();
                  }

                  loop();

              },

              methods: {

                }
            })



            app = new Vue({
              el: '#app',
              data: {
                dataObj : {
                  g: {
                    w:500,
                    h:500,
                    p:{
                      x:250,
                      prevx:250,
                      facing:null,
                      y:250,
                      d:15,
                      l:100,
                      ml:100,
                      speed:3,
                      mana:0,
                      manaLimit:150,
                      damage:1,
                      limitBullets:1,
                      bulletSpeed:15,
                      bulletSize:10,
                      bulletDamage:100,
                      canShoot:true,
                      shootFrequency:3000,
                      bullets:[],
                      kills:0,
                      regen:.1,
                      aurea:0,
                      aureaDamage:2,
                      canTurret:true,
                      turretFrequency:2000,
                      turretDim:8,
                      turretDamage:20,
                      turretStartLife:20,
                      turretLife:20,
                      turretLimit:0
                    },
                    limitEnemies:5,
                    addedEnemies:false,
                    enemies:[],
                    collectables:[],
                    turrets:[]
                  },
                  joypad: {
                    p: {
                      x:0,
                      y:0
                    }
                  },
                  menuItems : [],
                  reloader:0,
                  mainInterval:null,
                  version:211530
                }
              },
              mounted () {
                this.start();
                
              },
              methods: {
                  upgrade:function () {
                        var poss = [
                          {
                            class:'center',
                            html:'<div class="icon user">turrets</div>',
                            onclick:function(){
                                app.dataObj.menuItems = []
                                app.dataObj.g.p.turretLimit+=1;
                                app.start();
                            }
                          },
                          {
                            class:'center',
                            html:'<div class="icon user">shoot speed</div>',
                            onclick:function(){
                                app.dataObj.menuItems = []
                                app.dataObj.g.p.shootFrequency=app.dataObj.g.p.shootFrequency/3
                                app.start();
                            }
                          },
                          {
                            class:'center',
                            html:'<div class="icon user">bullets</div>',
                            onclick:function(){
                                app.dataObj.menuItems = []
                                app.dataObj.g.p.bulletSize+=5
                                app.dataObj.g.p.bulletDamage+=20
                                app.start();
                            }
                          },
                          /*{
                            class:'center',
                            html:'<div class="icon user">damage</div>',
                            onclick:function(){
                                app.dataObj.menuItems = []
                                app.dataObj.g.p.bulletDamage+=20
                                app.start();
                            }
                          },*/
                          {
                            class:'center',
                            html:'<div class="icon user">life max & regen</div>',
                            onclick:function(){
                                app.dataObj.menuItems = []
                                app.dataObj.g.p.ml *= 1.5
                                app.dataObj.g.p.l = app.dataObj.g.p.ml
                                app.dataObj.g.p.regen*=2;
                                app.start();
                            }
                          }
                        ]

                        if(app.dataObj.g.p.aurea<200) {
                          poss.push(
                            {
                              class:'center',
                              html:'<div class="icon user">aurea</div>',
                              onclick:function(){
                                  app.dataObj.menuItems = []
                                  if(app.dataObj.g.p.aurea==0)
                                    app.dataObj.g.p.aurea=20
                                  app.dataObj.g.p.aurea*=1.2
                                  app.dataObj.g.p.aureaDamage*=1.2
                                  app.start();
                              }
                            }
                          )
                        }
                        if(true || app.dataObj.g.p.d>5) {
                          poss.push(
                             {
                              class:'center',
                              html:'<div class="icon user">speed</div>',
                              onclick:function(){
                                  app.dataObj.menuItems = []
                                  app.dataObj.g.p.speed++;
                                  //app.dataObj.g.p.d-=5
                                  app.start();
                              }
                            },
                          )
                        }

                        var pots = [];
                        while(pots.length<3) {
                          var ri = app.rint(0,poss.length-1)
                          if(pots.indexOf(ri)==-1)
                            pots.push(ri)
                        }
                        app.dataObj.menuItems.push(
                          {
                            class:'center',
                            html:'<div class="icon user">UPGRADE</div>',
                          },
                        )
                        console.log(pots.length)
                        for (var i = 0; i < pots.length; i++) {
                          //console.log(poss[pots[i]])
                          app.dataObj.menuItems.push(poss[pots[i]])
                        }
                  },
                  start:function() {
                    this.dataObj.mainInterval = setInterval(function(){
                      engine(app)
                    },30)
                  },
                  stop:function() {
                    clearInterval(this.dataObj.mainInterval)
                    this.dataObj.mainInterval = null
                  },
                  getDistance:function(x1, y1, x2, y2){
                      let y = x2 - x1;
                      let x = y2 - y1;
                      return Math.sqrt(x * x + y * y);
                  },
                  rint:function(min, max) {
                    return Math.floor(Math.random() * (max - min + 1) + min)
                  }
                }
            }) 

        }

    </script>
    <script type="text/javascript">
      function engine(app) {
                  /*if(app.dataObj.g.collectables.length<=5) {
                  app.dataObj.g.collectables.push({
                    x:app.rint(app.dataObj.g.p.x-1000,app.dataObj.g.p.x+1000),
                    y:app.rint(app.dataObj.g.p.y-1000,app.dataObj.g.p.y+1000),
                    a:50,
                    d:10
                  });
                  }*/


                  // add enemy
                  if(app.dataObj.g.addedEnemies==false) {
                    for (var s = 0; s < app.dataObj.g.limitEnemies; s++) {
                      //if(app.dataObj.g.enemies.length<app.dataObj.g.limitEnemies) {
                        var epos;
                        var r = app.rint(0,3)
                        if(r==0) {
                          epos = {
                            x:app.rint(app.dataObj.g.p.x-250-20,app.dataObj.g.p.x+250+20),
                            y:app.rint(app.dataObj.g.p.y-250-20,app.dataObj.g.p.y-250-120)
                          }
                        }
                        if(r==1) {
                          epos = {
                            x:app.rint(app.dataObj.g.p.x-250-20,app.dataObj.g.p.x+250+20),
                            y:app.rint(app.dataObj.g.p.y+250+20,app.dataObj.g.p.y+250+120)
                          }
                        }
                        if(r==2) {
                          epos = {
                            x:app.rint(app.dataObj.g.p.x-250-20,app.dataObj.g.p.x-250-120),
                            y:app.rint(app.dataObj.g.p.y-250-20,app.dataObj.g.p.y+250+20)
                          }
                        }
                        if(r==3) {
                          epos = {
                            x:app.rint(app.dataObj.g.p.x+250+20,app.dataObj.g.p.x+250+120),
                            y:app.rint(app.dataObj.g.p.y-250-20,app.dataObj.g.p.y+250+20)
                          }
                        }
                        var rr = s;//app.rint(0,50)
                        if(app.dataObj.g.limitEnemies<100) rr = 1
                        app.dataObj.g.enemies.push({
                          id:app.rint(0,10000000),
                          x:epos.x,
                          y:epos.y,
                          d:(rr==0 ? 20 : 10),
                          type:(rr==0 ? 1 : 0),
                          l:(rr==0 ? 500+app.dataObj.g.p.kills/5 : 100+app.dataObj.g.p.kills/50),//100+app.dataObj.g.p.kills/50,
                          ml:(rr==0 ? 500+app.dataObj.g.p.kills/5 : 100+app.dataObj.g.p.kills/50),
                          s:1+app.dataObj.g.p.kills/1000,
                          damage:.1+app.dataObj.g.p.kills/1000,
                          manaAmount:(rr==0 ? 100 : 50),
                        })
                      //}
                    }
                    app.dataObj.g.addedEnemies = true;
                  }
                  

                  // add turrets
                  if(app.dataObj.g.p.canTurret && app.dataObj.g.turrets.length<app.dataObj.g.p.turretLimit){
                    var ano = 
                      {
                        x:app.rint(app.dataObj.g.p.x-100,app.dataObj.g.p.x+100),
                        y:app.rint(app.dataObj.g.p.y-100,app.dataObj.g.p.y+100)
                      }
                    app.dataObj.g.turrets.push(
                        {
                          x:ano.x,
                          y:ano.y,
                          d:app.dataObj.g.p.turretDim,
                          l:app.dataObj.g.p.turretLife,
                          ml:app.dataObj.g.p.turretStartLife,
                          canShoot:true,
                          damage:app.dataObj.g.p.bulletDamage,
                          shootFrequency:1000
                        }
                      )

                      app.dataObj.g.p.canTurret = false
                      setTimeout(function(){
                        app.dataObj.g.p.canTurret = true   
                      },app.dataObj.g.p.turretFrequency)
                  }

                  var outer = 500
                  // add bullets
                  var shoot = false;
                  //if(false)
                  if(app.dataObj.g.p.canShoot){// && app.dataObj.g.p.bullets.length<app.dataObj.g.p.limitBullets) {
                    var close = findClosest(app.dataObj.g.p,app.dataObj.g.enemies)

                    if(close) {
                      var e = app.dataObj.g.p
                      var x1 = app.dataObj.g.p.x;
                      var y1 = app.dataObj.g.p.y;
                      var x2 = close.x;
                      var y2 = close.y;
                      var x3 = app.dataObj.g.p.x-outer;
                      var y3 = app.dataObj.g.p.y-outer;
                      var x4 = app.dataObj.g.p.x+outer;
                      var y4 = app.dataObj.g.p.y-outer;
                      var inte = line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
                      if(inte && inte.seg2 && app.dataObj.g.p.y>close.y) {
                        shoot = true;
                      } else  {
                        var x3 = app.dataObj.g.p.x-outer;
                        var y3 = app.dataObj.g.p.y+outer;
                        var x4 = app.dataObj.g.p.x+outer;
                        var y4 = app.dataObj.g.p.y+outer;
                        var inte = line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
                        if(inte && inte.seg2 && app.dataObj.g.p.y<close.y) {
                          shoot = true;
                        } else {
                          var x3 = app.dataObj.g.p.x-outer;
                          var y3 = app.dataObj.g.p.y-outer;
                          var x4 = app.dataObj.g.p.x-outer;
                          var y4 = app.dataObj.g.p.y+outer;
                          var inte = line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
                          if(inte && inte.seg2 && app.dataObj.g.p.x>close.x) {
                            shoot = true;
                          } else {
                            var x3 = app.dataObj.g.p.x+outer;
                            var y3 = app.dataObj.g.p.y-outer;
                            var x4 = app.dataObj.g.p.x+outer;
                            var y4 = app.dataObj.g.p.y+outer;
                            var inte = line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
                            if(inte && inte.seg2 && app.dataObj.g.p.x<close.x) {
                              shoot = true;
                            }
                          }
                        }
                      }
                    }
                    if(shoot==true) {
                      app.dataObj.g.p.bullets.push(
                        {
                          x:app.dataObj.g.p.x,
                          y:app.dataObj.g.p.y,
                          d:app.dataObj.g.p.bulletSize,
                          damage:app.dataObj.g.p.bulletDamage,
                          objective:{x:inte.x,y:inte.y,d:1}
                        }
                      )

                      app.dataObj.g.p.canShoot = false
                      setTimeout(function(){
                        app.dataObj.g.p.canShoot = true   
                      },app.dataObj.g.p.shootFrequency)
                    }
                  }
                  // add turrets bullets
                  for (var v = 0; v < app.dataObj.g.turrets.length; v++) {
                    let t = app.dataObj.g.turrets[v];
                    var shoot = false;
                    if(t.canShoot){
                      var close = findClosest(t,app.dataObj.g.enemies)
                      if(close) {
                        var x1 = t.x;
                        var y1 = t.y;
                        var x2 = close.x;
                        var y2 = close.y;
                        var x3 = t.x-outer;
                        var y3 = t.y-outer;
                        var x4 = t.x+outer;
                        var y4 = t.y-outer;
                        var inte = line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
                        if(inte && inte.seg2 && t.y>close.y) {
                          shoot = true;
                        } else  {
                          var x3 = t.x-outer;
                          var y3 = t.y+outer;
                          var x4 = t.x+outer;
                          var y4 = t.y+outer;
                          var inte = line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
                          if(inte && inte.seg2 && t.y<close.y) {
                            shoot = true;
                          } else {
                            var x3 = t.x-outer;
                            var y3 = t.y-outer;
                            var x4 = t.x-outer;
                            var y4 = t.y+outer;
                            var inte = line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
                            if(inte && inte.seg2 && t.x>close.x) {
                              shoot = true;
                            } else {
                              var x3 = t.x+outer;
                              var y3 = t.y-outer;
                              var x4 = t.x+outer;
                              var y4 = t.y+outer;
                              var inte = line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
                              if(inte && inte.seg2 && t.x<close.x) {
                                shoot = true;
                              }
                            }
                          }
                        }
                      }
                      if(shoot==true) {
                        if(inte.x>t.x) {
                          t.facing = "right"
                        } else {
                          t.facing = "left"
                        }
                        app.dataObj.g.p.bullets.push(
                          {
                            x:t.x,
                            y:t.y,
                            d:5,
                            damage:t.damage,
                            objective:{x:inte.x,y:inte.y,d:1}
                          }
                        )

                        t.canShoot = false
                        setTimeout(function(){
                          t.canShoot = true   
                        },app.dataObj.g.p.shootFrequency)
                      }
                    }
                  }

                  // handle bullets
                  var updatedBullets = []
                  for (var i = app.dataObj.g.p.bullets.length - 1; i >= 0; i--) {
                    var e = app.dataObj.g.p.bullets[i];
                    var a = findClosest(e,app.dataObj.g.enemies); //find closest
                    if(a) {
                      var outer = app.dataObj.g.w*10
                      if(e.x<app.dataObj.g.p.x-outer || e.x > app.dataObj.g.p.x+outer || e.y<app.dataObj.g.p.y-outer || e.y > app.dataObj.g.p.y+outer) {
                        //console.log('out')
                      }
                      else
                       if (app.getDistance(e.x,e.y,a.x,a.y)<app.dataObj.g.p.bulletSize) {
                        //console.log('hit')
                        a.l -= e.damage

                      }
                      else if (app.getDistance(e.x,e.y,e.objective.x,e.objective.y)>app.dataObj.g.p.bulletSize) {

                        var mid = midpoint(e.x,e.y,e.objective.x,e.objective.y)
                        
                        var cdistance = app.getDistance(e.x,e.y,mid[0],mid[1])
                        while (cdistance>app.dataObj.g.p.bulletSpeed) {
                          mid = midpoint(e.x,e.y,mid[0],mid[1])
                          cdistance = app.getDistance(e.x,e.y,mid[0],mid[1])
                        }
                        e.x = mid[0]
                        e.y = mid[1]

                        updatedBullets.push(e)

                      } else {
                        //console.log('hit')

                      }
                    }
                  }
                  app.dataObj.g.p.bullets = updatedBullets;

                  // handle enemies
                  var updatedEnemies = []
                  for (var i = app.dataObj.g.enemies.length - 1; i >= 0; i--) {
                    var e = app.dataObj.g.enemies[i];
                    //if(false)
                    if (app.getDistance(e.x,e.y,app.dataObj.g.p.x,app.dataObj.g.p.y)>app.dataObj.g.p.d+e.d) {
                      
                      var mid = midpoint(e.x,e.y,app.dataObj.g.p.x,app.dataObj.g.p.y)
                      var cdistance = app.getDistance(e.x,e.y,mid[0],mid[1])
                      while (cdistance>2) {
                        mid = midpoint(e.x,e.y,mid[0],mid[1])
                        cdistance = app.getDistance(e.x,e.y,mid[0],mid[1])
                      }
                      
                      var closest = findClosest(e,app.dataObj.g.enemies);
                      if(!closest || app.getDistance(e.x,e.y,closest.x,closest.y)>e.d*2) {
                        e.x = mid[0]
                        e.y = mid[1]
                      } else {
                        var ra = app.rint(0,4);
                        if(ra==0) {
                          e.x+=e.d;
                        }
                        if(ra==1) {
                          e.x-=e.d;
                        }
                        if(ra==2) {
                          e.y+=e.d;
                        }
                        if(ra==3) {
                          e.y-=e.d;
                        }

                      }

                    } else {
                      /*e.l-=app.dataObj.g.p.damage;
                      app.dataObj.g.p.l-=e.damage*/
                      app.dataObj.g.p.l-=e.damage
                    }

                    if (app.getDistance(e.x,e.y,app.dataObj.g.p.x,app.dataObj.g.p.y)<(app.dataObj.g.p.d+e.d)+app.dataObj.g.p.aurea) {
                      e.l-=app.dataObj.g.p.aureaDamage;
                    }

                    if(app.dataObj.g.p.l<=0) {

                      app.stop()
                      app.dataObj.menuItems.push(
                        {
                          class:'center',
                          html:'<div class="icon user">retry</div>',
                          onclick:function(){
                              window.location.reload()
                          }
                        }
                      )
                      return;
                    }
                    if(e.l>0) {
                      updatedEnemies.push(e)
                    } else {
                      app.dataObj.g.p.kills++
                      if(e.type==1) {
                        if(app.dataObj.g.collectables.length<=1)
                        app.dataObj.g.collectables.push({
                          x:e.x,
                          y:e.y,
                          a:50,
                          d:10
                        });
                      }

                      /*if(app.dataObj.g.p.kills%30==0) {
                        app.dataObj.g.limitEnemies++;
                      }*/


                      app.dataObj.g.p.mana+=e.manaAmount


                      if(app.dataObj.g.p.mana>=app.dataObj.g.p.manaLimit) {
                        app.stop()
                        app.upgrade()
                        app.dataObj.g.p.mana=0
                        app.dataObj.g.p.manaLimit*=1.5
                        
                        return
                      }

                    }
                  }
                  app.dataObj.g.enemies = updatedEnemies;


                  // handle turrets
                  var updatedTurrets = []
                  for (var i = app.dataObj.g.turrets.length - 1; i >= 0; i--) {
                    let e = app.dataObj.g.turrets[i];
                    e.l-=0.1;
                    if (e.l>0) {
                      updatedTurrets.push(e)
                    } else {
                      
                    }
                  }
                  app.dataObj.g.turrets = updatedTurrets;

                  //mana
                  var updatedCollectables = []
                  for (var i = app.dataObj.g.collectables.length - 1; i >= 0; i--) {
                    var e = app.dataObj.g.collectables[i];
                    if (app.getDistance(e.x,e.y,app.dataObj.g.p.x,app.dataObj.g.p.y)<app.dataObj.g.p.d+e.d) {
                      app.stop()
                      app.upgrade()
                    } else {
                      updatedCollectables.push(e)
                    }
                  }
                  app.dataObj.g.collectables = updatedCollectables;

                  //regen
                  if(app.dataObj.g.p.l<app.dataObj.g.p.ml)
                    app.dataObj.g.p.l+=app.dataObj.g.p.regen
                  app.dataObj.reloader++

                  if(app.dataObj.g.enemies.length==0) {
                    console.log(app.dataObj.g.limitEnemies)
                    app.dataObj.g.limitEnemies*=1.5;
                    if(app.dataObj.g.limitEnemies>400)
                      app.dataObj.g.limitEnemies = 400;
                    app.dataObj.g.addedEnemies = false;
                  }

      }
      function findClosest(ca,ce){
        var min = 1000;
        var index;
        for (var i = 0; i < ce.length; i++) {
          var t = app.getDistance(ca.x,ca.y,ce[i].x,ce[i].y);
          if(t<min) {
            if(ca.id) {
              if(ca.id!=ce[i].id) {
                min = t;
                index = i
              }
            } else {
              min = t;
            index = i
            }
            
          }
        }
        return ce[index]
      }
      function line_intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
          var ua, ub, denom = (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1);
          if (denom == 0) {
              return null;
          }
          ua = ((x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3))/denom;
          ub = ((x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3))/denom;
          return {
              x: x1 + ua * (x2 - x1),
              y: y1 + ua * (y2 - y1),
              seg1: ua >= 0 && ua <= 1,
              seg2: ub >= 0 && ub <= 1
          };
      }
      function midpoint(x1, y1, x2, y2) {
        return [(x1 + x2) / 2, (y1 + y2) / 2];
      }
    </script>
</head>

<body>
    <div id="app">
      <div>
        <heromana-item 
          v-bind:p="dataObj.g.p"
          
          >
        </heromana-item>
        <canvas-item 
          v-bind:g="dataObj.g"
          v-bind:key="dataObj.reloader"
          >
        </canvas-item>
        
        <stats-item 
          v-bind:p="dataObj.g.p"
          v-bind:e="dataObj.g.enemies"
          v-bind:v="dataObj.version"
          >
        </stats-item>
      <div>
    </div>
    <joypad-item 
          v-bind:joypad="dataObj.joypad"
          >
    </joypad-item>
    <div class="panrelOverlay" v-if="dataObj.menuItems.length"></div>
    <div class="panel" v-if="dataObj.menuItems">
      <menu-item
        v-for="item in dataObj.menuItems"
        v-bind:item="item"
      ></menu-item>
    </div>
    <img src="./imgs/bg.jpg" id="bg" style="display:none;"></img>
    <img id="villain" style="display:none;" src="./imgs/villain.png"></img>
    <img id="villain2" style="display:none;" src="./imgs/villain2.png"></img>
    <img id="hero" style="display:none;" src="./imgs/hero.png"></img>
    <img id="turret" style="display:none;" src="./imgs/turret.png"></img>
    <img id="tturret" style="display:none;" src="./imgs/tturret.png"></img>
    <img id="powerup" style="display:none;" src="./imgs/powerup.png"></img>
    <!-- <img id="bullet" style="display:none;" src="./imgs/bullet.png"></img> -->
</body>

</html>